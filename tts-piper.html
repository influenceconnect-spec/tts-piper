<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <title>Texte ‚Üí Parole (Piper + fallback WAV)</title>
  <style>
    :root{ color-scheme: light dark; }
    body{margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial; background:#222222; color:#f2f2f2}
    .page{min-height:100svh; display:grid; place-items:center; padding:clamp(12px, 2.5vw, 32px)}
    .demo{max-width:900px; width:100%}
    details{margin-top:10px; color:#bbb}
    summary{cursor:pointer}
    code{background:#0003; padding:2px 6px; border-radius:6px}
  </style>
</head>
<body>
  <div class="page">
    <div class="demo">
      <tts-widget></tts-widget>
      <details>
        <summary>üß™ Diagnostic & tests</summary>
        <div style="font-size:.9rem; line-height:1.6; margin-top:8px">
          <div id="diag"></div>
          <button id="selftest" class="btn" style="margin-top:8px;border:1px solid #00FFA3;background:#00FFA3;color:#000;padding:8px 12px;border-radius:999px;font-weight:600">‚ñ∂Ô∏è Lancer l'auto‚Äëtest</button>
        </div>
      </details>
    </div>
  </div>

  <!-- 1) meSpeak (fallback garanti WAV, sans quota) -->
  <script src="https://cdn.jsdelivr.net/npm/mespeak/mespeak.min.js"></script>

  <!-- 2) Piper (voix neurales r√©alistes) : module ESM, peut √™tre bloqu√© dans certains contextes -->
  <script type="module">
    // On tente de charger Piper (ESM). Si √©chec ‚Üí on reste en fallback meSpeak uniquement.
    let piper = null;
    try { piper = await import('https://cdn.jsdelivr.net/npm/@mintplex-labs/piper-tts-web/+esm'); }
    catch (e) { console.warn('Piper non charg√© (ESM):', e); }

    const BRAND = '#00FFA3';

    // Mod√®les FR connus c√¥t√© Piper (IDs officiels)
    const PIPER_FR = [
      { id: 'fr_FR-siwis-medium', label: 'FR ‚Äî siwis (medium)' },
      { id: 'fr_FR-tom-medium',   label: 'FR ‚Äî tom (medium)' },
      { id: 'fr_FR-gilles-low',   label: 'FR ‚Äî gilles (low)' },
      { id: 'fr_FR-upmc-medium',  label: 'FR ‚Äî upmc (medium)' }
    ];

    // Fallback meSpeak (voix FR int√©gr√©e)
    const MESPEAK_VOICE = { id: 'me:fr', label: 'FR ‚Äî Classique (meSpeak, t√©l√©chargement garanti)' };

    const $ = (root, sel) => root.querySelector(sel);
    const setTxt = (el, t) => { if(el) el.textContent = t; };

    class TTSWidget extends HTMLElement{
      constructor(){ super(); this.attachShadow({mode:'open'}); }
      connectedCallback(){ if(!this._init){ this._render(); this._bind(); this._init=true; this._onReady(); } }

      _render(){
        const html = `
        <style>
          *,*::before,*::after{box-sizing:border-box}
          :host{--radius:16px; --gap:12px; --pad:14px; --bg:#2b2b2b; --border:#3b3b3b; --text:#f2f2f2; --muted:#bfbfbf; --brand:${BRAND}; display:block}
          .card{background:var(--bg); border:1px solid var(--border); border-radius:16px; padding:clamp(12px, 2.2vw, 18px); width:100%;}
          .header{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px}
          .title{font-weight:700; font-size:clamp(1.1rem, 1.2vw + .8rem, 1.5rem);}
          .status{font-size:.9rem; color:var(--muted)}
          .grid{display:grid; gap:12px; grid-auto-rows:min-content}
          @media(min-width:900px){.grid{grid-template-columns: minmax(0,1fr) minmax(260px, 420px);}}
          .fieldset{display:grid; gap:8px; min-width:0}
          label{font-size:.9rem; color:var(--muted)}
          select, textarea, input[type="range"], button{font: inherit; color:var(--text)}
          textarea{resize:none; min-height:160px; width:100%; border-radius:12px; padding:14px; outline:none; border:1px solid var(--border); background:#1f1f1f}
          textarea:focus{box-shadow: 0 0 0 3px rgba(0,255,163,.25)}
          .controls{display:flex; flex-wrap:wrap; gap:10px}
          .btn{border:1px solid var(--brand); background:var(--brand); padding:10px 14px; border-radius:999px; cursor:pointer; display:inline-flex; gap:8px; align-items:center; color:#000; font-weight:700}
          .btn[disabled]{opacity:.6; cursor:not-allowed}
          .btn:hover{filter:brightness(1.03)}
          .btn:focus-visible{outline:none; box-shadow:0 0 0 3px rgba(0,255,163,.4)}
          .sliders{display:grid; gap:8px}
          .slider-row{display:grid; grid-template-columns: 1fr auto; align-items:center; gap:10px}
          input[type="range"]{width:100%; accent-color: var(--brand);}
          input[type="range"]::-webkit-slider-runnable-track{height:6px; border-radius:999px; background: rgba(0,255,163,.3)}
          input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none; appearance:none; width:18px; height:18px; border-radius:50%; background: var(--brand); border:2px solid #000; margin-top:-6px}
          input[type="range"]::-moz-range-track{height:6px; border-radius:999px; background: rgba(0,255,163,.3)}
          input[type="range"]::-moz-range-thumb{width:18px; height:18px; border-radius:50%; background: var(--brand); border:2px solid #000}
          select{width:100%; max-width:100%; border:1px solid var(--border); border-radius:12px; padding:10px; background:#1f1f1f}
          .meta{display:flex; justify-content:space-between; font-size:.85rem; color:var(--muted)}
          .foot{margin-top:8px; font-size:.8rem; color:var(--muted)}
          .steps{display:grid; gap:6px; margin-bottom:8px}
          .step{font-weight:700; color:#fff}
          .step em{color:${BRAND}; font-style:normal}
          audio{width:100%; margin-top:6px}
          progress{width:100%; height:10px; border-radius:10px; overflow:hidden}
        </style>
        <div class='card'>
          <div class='header'>
            <div class='title'>Texte ‚Üí Parole (Piper + WAV)</div>
            <div class='status' id='status' aria-live='polite'>Pr√™t</div>
          </div>
          <div class='grid'>
            <div class='fieldset'>
              <div class='steps'>
                <div class='step'>√âtape 1 ‚Äî <em>Choisis une voix</em></div>
                <div class='step'>√âtape 2 ‚Äî <em>Pr√©charge la voix</em> (1√®re fois)</div>
                <div class='step'>√âtape 3 ‚Äî <em>√âcris ton texte</em></div>
                <div class='step'>√âtape 4 ‚Äî <em>√âcoute</em> puis <em>T√©l√©charge</em></div>
              </div>
              <label for='voice'>Voix utilisables (t√©l√©chargeables)</label>
              <select id='voice' aria-label='Choisir la voix'></select>
              <div class='controls'>
                <button class='btn' id='preload'>‚¨áÔ∏è Pr√©charger la voix</button>
                <button class='btn' id='preview'>‚ñ∂Ô∏è √âcouter</button>
              </div>
              <div class='foot'>Premi√®re fois : le mod√®le (8‚Äì20 Mo) se t√©l√©charge et reste en cache navigateur (Piper). Le mode meSpeak ne t√©l√©charge rien.</div>
              <progress id='dlprog' max='100' value='0' hidden></progress>
              <div id='dlmsg' style='font-size:.85rem;color:#bbb'></div>
            </div>
            <div class='fieldset'>
              <label for='text'>Texte</label>
              <textarea id='text' placeholder='√âcris ou colle un texte ici‚Ä¶'>Bonjour et bienvenue sur notre synth√®se vocale en ligne.</textarea>
              <div class='meta'><span id='count'>0 caract√®re</span><span id='modelInfo'></span></div>
              <div class='sliders'>
                <div class='slider-row'>
                  <label for='rate'>Vitesse (sortie): <span id='rateVal'>1.00√ó</span></label>
                  <input id='rate' type='range' min='0.7' max='1.4' value='1' step='0.05' />
                </div>
              </div>
              <div class='controls'>
                <button class='btn' id='download'>üíæ T√©l√©charger</button>
              </div>
              <audio id='player' controls hidden></audio>
            </div>
          </div>
        </div>`;
        const tpl = document.createElement('template');
        tpl.innerHTML = html;
        this.shadowRoot.appendChild(tpl.content.cloneNode(true));

        // refs
        this.$ = (sel)=>$(this.shadowRoot, sel);
        this.$voice = this.$('#voice');
        this.$preload = this.$('#preload');
        this.$preview = this.$('#preview');
        this.$text = this.$('#text');
        this.$count = this.$('#count');
        this.$rate = this.$('#rate');
        this.$rateVal = this.$('#rateVal');
        this.$status = this.$('#status');
        this.$modelInfo = this.$('#modelInfo');
        this.$download = this.$('#download');
        this.$prog = this.$('#dlprog');
        this.$msg = this.$('#dlmsg');
        this.$player = this.$('#player');
        // diag (hors shadow)
        this.$diag = document.getElementById('diag');

        // state
        this.storeKey = 'tts_piper_widget_v4';
        this.state = { voiceId:'', rate:1, text:'' };

        // runtime flags
        this._piper = piper || null;       // null si non charg√©
        this._meReady = false;             // meSpeak pr√™t ?
      }

      _bind(){
        this.$voice.addEventListener('change', ()=>{ this.state.voiceId = this.$voice.value; this._save(); this._updateModelInfo(); });
        this.$preload.addEventListener('click', ()=> this.preloadSelected());
        this.$preview.addEventListener('click', ()=> this.handlePreview());
        this.$download.addEventListener('click', ()=> this.handleDownload());
        this.$text.addEventListener('input', ()=>{ this.state.text=this.$text.value; this._save(); this._updateCount(); this._autoresize(); });
        this.$rate.addEventListener('input', ()=>{ this.state.rate=parseFloat(this.$rate.value)||1; setTxt(this.$rateVal, this.state.rate.toFixed(2)+'√ó'); this._save(); });
        const selftestBtn = document.getElementById('selftest');
        if(selftestBtn) selftestBtn.addEventListener('click', ()=> this.runSelfTest());
      }

      async _onReady(){
        this._load();
        await this.ensureMeSpeak();
        this._populateVoices();
        setTxt(this.$rateVal, (this.state.rate||1).toFixed(2)+'√ó');
        if(this.state.text) this.$text.value = this.state.text;
        this._autoresize(); this._updateCount(); this._updateModelInfo();
        this.$download.disabled = false; // t√©l√©chargement possible via meSpeak m√™me sans Piper
        if(!this._piper){ this._setStatus('Piper indisponible ici ‚Üí fallback meSpeak actif'); }
      }

      // ------- Loaders -------
      async ensureMeSpeak(){
        if(this._meReady) return true;
        try{
          await new Promise((resolve, reject)=>{
            // le core inclut une config par d√©faut depuis meSpeak 2.0 ; on charge juste la voix FR
            window.meSpeak.loadVoice('https://cdn.jsdelivr.net/npm/mespeak/voices/fr.json', (ok)=> ok? resolve(): reject(new Error('voice load')));
          });
          this._meReady = true; return true;
        }catch(e){ this.diag('‚ùå meSpeak voice FR: '+(e&&e.message?e.message:e)); return false; }
      }

      _populateVoices(){
        this.$voice.innerHTML='';
        if(this._piper){ for(const v of PIPER_FR){ const opt=document.createElement('option'); opt.value=v.id; opt.textContent=v.label; this.$voice.appendChild(opt); } }
        // Toujours ajouter le fallback meSpeak (t√©l√©chargeable partout)
        const optMe = document.createElement('option'); optMe.value = MESPEAK_VOICE.id; optMe.textContent = MESPEAK_VOICE.label; this.$voice.appendChild(optMe);
        // S√©lection
        const allowed = [...(this._piper?PIPER_FR.map(v=>v.id):[]), MESPEAK_VOICE.id];
        this.$voice.value = (this.state.voiceId && allowed.includes(this.state.voiceId)) ? this.state.voiceId : (this._piper?PIPER_FR[0].id:MESPEAK_VOICE.id);
        this.state.voiceId = this.$voice.value; this._save();
      }

      // ------- UI helpers -------
      _updateCount(){ const n=(this.$text.value||'').length; setTxt(this.$count, n+(n>1?' caract√®res':' caract√®re')); }
      _autoresize(){ const el=this.$text; el.style.height='auto'; const max=420; el.style.height=Math.min(el.scrollHeight+2, max)+'px'; }
      _setStatus(s){ setTxt(this.$status,s); }
      _updateModelInfo(){ const id=this.$voice.value; setTxt(this.$modelInfo, id?('Source: '+(id.startsWith('me:')?'meSpeak (WAV local)':'Piper (neural)')):''); }
      diag(line){ const d=document.getElementById('diag'); if(d){ d.insertAdjacentHTML('beforeend','<div>'+line+'</div>'); } }

      // ------- Actions -------
      async preloadSelected(){
        const id=this.$voice.value;
        if(id.startsWith('me:')){ this._setStatus('Rien √† pr√©charger (meSpeak).'); return; }
        if(!this._piper){ this._setStatus('Piper indisponible (contexte).'); return; }
        this.$preload.disabled = true; this.$prog.hidden=false; this.$prog.value=0; setTxt(this.$msg,'T√©l√©chargement du mod√®le‚Ä¶');
        try{
          await this._piper.download(id, (prog)=>{ if(prog && prog.total){ const v=Math.round((prog.loaded*100)/prog.total); this.$prog.value=v; setTxt(this.$msg, 'T√©l√©chargement '+v+'% ‚Äî '+(prog.url.split('/').pop())); } });
          setTxt(this.$msg, 'Mod√®le en cache ‚úÖ'); this._setStatus('Pr√™t');
        }catch(e){
          setTxt(this.$msg, '√âchec t√©l√©chargement : '+(e&&e.message?e.message:e));
          this.diag('‚ùå Piper download '+id+': '+(e&&e.message?e.message:e));
        }finally{ this.$preload.disabled=false; this.$prog.hidden=true; }
      }

      async handlePreview(){
        const text=(this.$text.value||'').trim() || 'Bonjour, ceci est un test.';
        const id=this.$voice.value;
        // 1) Piper si dispo ET si une voix Piper est choisie
        if(this._piper && !id.startsWith('me:')){
          try{
            this._setStatus('G√©n√©ration (Piper)‚Ä¶');
            const wav = await this._piper.predict({ text, voiceId: id });
            const url = URL.createObjectURL(wav);
            this.$player.hidden=false; this.$player.src=url; await this.$player.play().catch(()=>{});
            this._setStatus('Lecture (Piper)'); return;
          }catch(e){
            this.diag('‚ùå preview/predict (Piper): '+(e&&e.message?e.message:e));
            this._setStatus('Piper en erreur, bascule meSpeak‚Ä¶');
          }
        }
        // 2) meSpeak (garanti)
        if(await this.ensureMeSpeak()){
          try{
            const wavBlob = await this.meSpeakWav(text);
            const url = URL.createObjectURL(wavBlob);
            this.$player.hidden=false; this.$player.src=url; await this.$player.play().catch(()=>{});
            this._setStatus('Lecture (meSpeak)'); return;
          }catch(e){ this.diag('‚ùå meSpeak preview: '+(e&&e.message?e.message:e)); this._setStatus('Lecture indisponible.'); }
        } else { this._setStatus('Lecture indisponible.'); }
      }

      async handleDownload(){
        const text=(this.$text.value||'').trim(); if(!text){ this._setStatus('Ajoute du texte.'); this.$text.focus(); return; }
        const id=this.$voice.value;
        let blob=null;
        if(this._piper && !id.startsWith('me:')){
          try{
            this._setStatus('G√©n√©ration (Piper)‚Ä¶');
            blob = await this._piper.predict({ text, voiceId: id });
          }catch(e){ this.diag('‚ùå predict (Piper): '+(e&&e.message?e.message:e)); this._setStatus('Piper en erreur, bascule meSpeak‚Ä¶'); }
        }
        if(!blob){
          try{ blob = await this.meSpeakWav(text); }
          catch(e){ this._setStatus('G√©n√©ration impossible.'); this.diag('‚ùå meSpeak gen: '+(e&&e.message?e.message:e)); return; }
        }
        // Vitesse (re-√©chantillonnage simple)
        const rate=parseFloat(this.$rate.value)||1; if(Math.abs(rate-1)>0.01){ try{ blob = await this.timeStretchWav(blob, rate); }catch(e){ this.diag('‚ö†Ô∏è timeStretch: '+(e&&e.message?e.message:e)); } }
        this.downloadBlob(blob, `tts-${this.timestamp()}.wav`);
        this._setStatus('WAV t√©l√©charg√© ‚úÖ');
      }

      // ------- meSpeak helper ‚Üí WAV Blob -------
      async meSpeakWav(text){
        await this.ensureMeSpeak();
        return await new Promise((resolve, reject)=>{
          try{
            window.meSpeak.speak(text, { rawdata: true, voice: 'fr', speed: 170, pitch: 55, amplitude: 100 }, (ok, id, stream)=>{
              if(ok && stream){ resolve(new Blob([stream], {type:'audio/wav'})); }
              else reject(new Error('meSpeak stream vide'));
            });
          }catch(e){ reject(e); }
        });
      }

      // ------- Audio helpers -------
      async decodeWavToAudioBuffer(blob){ const ac = new (window.AudioContext||window.webkitAudioContext)(); const ab = await blob.arrayBuffer(); const buf = await ac.decodeAudioData(ab); return { ac, buf }; }
      async timeStretchWav(wavBlob, rate){ const { ac, buf } = await this.decodeWavToAudioBuffer(wavBlob); const duration = buf.duration / rate; const off = new OfflineAudioContext({ numberOfChannels: buf.numberOfChannels, length: Math.ceil(duration*ac.sampleRate), sampleRate: ac.sampleRate }); const src = new AudioBufferSourceNode(off, { buffer: buf, playbackRate: rate }); src.connect(off.destination); src.start(); const rendered = await off.startRendering(); return this.encodeWav(rendered); }
      encodeWav(audioBuffer){ const numCh=audioBuffer.numberOfChannels, sr=audioBuffer.sampleRate; const chans=[]; for(let c=0;c<numCh;c++) chans.push(audioBuffer.getChannelData(c)); const frames=audioBuffer.length; const inter=new Float32Array(frames*numCh); for(let i=0;i<frames;i++){ for(let c=0;c<numCh;c++){ inter[i*numCh+c]=chans[c][i]; } } const pcm16=new Int16Array(inter.length); for(let i=0;i<inter.length;i++){ let x=Math.max(-1,Math.min(1,inter[i])); pcm16[i]= x<0 ? x*0x8000 : x*0x7FFF; } const byteRate=sr*numCh*2, blockAlign=numCh*2; const buffer=new ArrayBuffer(44+pcm16.byteLength); const view=new DataView(buffer); let p=0; const wstr=s=>{ for(let i=0;i<s.length;i++) view.setUint8(p++, s.charCodeAt(i)); }; const w16=v=>{ view.setUint16(p,v,true); p+=2; }; const w32=v=>{ view.setUint32(p,v,true); p+=4; }; wstr('RIFF'); w32(36+pcm16.byteLength); wstr('WAVE'); wstr('fmt '); w32(16); w16(1); w16(numCh); w32(sr); w32(byteRate); w16(blockAlign); w16(16); wstr('data'); w32(pcm16.byteLength); new Uint8Array(buffer,44).set(new Uint8Array(pcm16.buffer)); return new Blob([buffer],{type:'audio/wav'}); }
      timestamp(){ const d=new Date(); const pad=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`; }
      downloadBlob(blob, filename){ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=filename; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1000); }

      // ------- Diagnostic + tests -------
      async runSelfTest(){
        const out=[]; out.push('Navigator.isSecureContext='+(window.isSecureContext?'‚úÖ':'‚ö†Ô∏è'));
        out.push('Piper charg√© (ESM): '+(this._piper?'‚úÖ':'‚ùå'));
        out.push('meSpeak pr√™t: '+(this._meReady?'‚úÖ':'‚ùå'));
        out.push('Voix list√©es: '+ Array.from(this.$voice.options).map(o=>o.textContent).join(' | '));
        // Test meSpeak
        try{ const wav=await this.meSpeakWav('Bonjour test.'); out.push('meSpeak WAV: '+wav.size+' octets ‚úÖ'); }
        catch(e){ out.push('meSpeak WAV KO: '+(e&&e.message?e.message:e)); }
        // Test Piper (si dispo)
        if(this._piper){
          try{ const wav=await this._piper.predict({ text:'Test Piper.', voiceId: PIPER_FR[0].id }); out.push('Piper WAV: '+wav.size+' octets ‚úÖ'); }
          catch(e){ out.push('Piper KO: '+(e&&e.message?e.message:e)); }
        }
        this.diag(out.join('<br>'));
      }
    }

    customElements.define('tts-widget', TTSWidget);
  </script>
</body>
</html>
